```
Roberto Nogueira  BSd EE, MSd CE
Solution Integrator Experienced - Certified by Ericsson
```

![ebook cover](images/erlang-programming.png)`

# Erlang Programming

## Contents

```
Chapter 1 Introduction
[ ] Why Should I Use Erlang?
[ ] The History of Erlang
[ ] Erlangâ€™s Characteristics
[ ] Erlang and Multicore
[ ] Case Studies
[ ] How Should I Use Erlang?

Chapter 2 Basic Erlang
[ ] Integers
[ ] The Erlang Shell
[ ] Floats
[ ] Atoms
[ ] Booleans
[ ] Tuples
[ ] Lists
[ ] Term Comparison
[ ] Variables
[ ] Complex Data Structures
[ ] Pattern Matching
[ ] Functions
[ ] Modules
[ ] Exercises

Chapter 3 Sequential Erlang
[ ] Conditional Evaluations
[ ] Guards
[ ] Built-in Functions
[ ] Recursion
[ ] Runtime Errors
[ ] Handling Errors
[ ] Library Modules
[ ] The Debugger
[ ] Exercises

Chapter 4 Concurrent Programming
[ ] Creating Processes
[ ] Message Passing
[ ] Receiving Messages
[ ] Registered Processes
[ ] Timeouts
[ ] Benchmarking
[ ] Process Skeletons
[ ] Tail Recursion and Memory Leaks
[ ] A Case Study on Concurrency-Oriented Programming
[ ] Race Conditions, Deadlocks, and Process Starvation
[ ] The Process Manager
[ ] Exercises

Chapter 5 Process Design Patterns
[ ] Client/Server Models
[ ] A Process Pattern Example
[ ] Finite State Machines
[ ] Event Managers and Handlers
[ ] Exercises

Chapter 6 Process Error Handling
[ ] Process Links and Exit Signals
[ ] Robust Systems
[ ] Exercises

Chapter 7 Records and Macros
[ ] Records
[ ] Macros
[ ] Exercises

Chapter 8 Software Upgrade
[ ] Upgrading Modules
[ ] Behind the Scenes
[ ] Upgrading Processes
[ ] The .erlang File
[ ] Exercise

Chapter 9 More Data Types and High-Level Constructs
[ ] Functional Programming for Real
[ ] Funs and Higher-Order Functions
[ ] List Comprehensions
[ ] Binaries and Serialization
[ ] References
[ ] Exercises

Chapter 10 ETS and Dets Tables
[ ] ETS Tables
[ ] Dets Tables
[ ] A Mobile Subscriber Database Example
[ ] Exercises

Chapter 11 Distributed Programming in Erlang
[ ] Distributed Systems in Erlang
[ ] Distributed Computing in Erlang: The Basics
[ ] The epmd Process
[ ] Exercises

Chapter 12 OTP Behaviors
[ ] Introduction to OTP Behaviors
[ ] Generic Servers
[ ] Supervisors
[ ] Applications
[ ] Release Handling
[ ] Other Behaviors and Further Reading
[ ] Exercises

Chapter 13 Introducing Mnesia
[ ] When to Use Mnesia
[ ] Configuring Mnesia
[ ] Transactions
[ ] Partitioned Networks
[ ] Further Reading
[ ] Exercises

Chapter 14 GUI Programming with wxErlang
[ ] wxWidgets
[ ] wxErlang: An Erlang Binding for wxWidgets
[ ] A First Example: MicroBlog
[ ] The MiniBlog Example
[ ] Obtaining and Running wxErlang
[ ] Exercises

Chapter 15 Socket Programming
[ ] User Datagram Protocol
[ ] Transmission Control Protocol
[ ] The inet Module
[ ] Further Reading
[ ] Exercises

Chapter 16 Interfacing Erlang with Other Programming Languages
[ ] An Overview of Interworking
[ ] Interworking with Java
[ ] C Nodes
[ ] Erlang from the Unix Shell: erl_call
[ ] Port Programs
[ ] Library Support for Communication
[ ] Linked-in Drivers and the FFI
[ ] Exercises

Chapter 17 Trace BIFs, the dbg Tracer, and Match Specifications
[ ] Introduction
[ ] The Trace BIFs
[ ] Tracing Calls with the trace_pattern BIF
[ ] The dbg Tracer
[ ] Match Specifications: The fun Syntax
[ ] Match Specifications: The Nuts and Bolts
[ ] Further Reading
[ ] Exercises

Chapter 18 Types and Documentation
[ ] Types in Erlang
[ ] TypEr: Success Types and Type Inference
[ ] Documentation with EDoc
[ ] Exercises

Chapter 19 EUnit and Test-Driven Development
[ ] Test-Driven Development
[ ] EUnit
[ ] The EUnit Infrastructure
[ ] Testing State-Based Systems
[ ] Testing Concurrent Programs in Erlang
[ ] Exercises

Chapter 20 Style and Efficiency
[ ] Applications and Modules
[ ] Processes and Concurrency
[ ] Stylistic Conventions
[ ] Coding Strategies
[ ] Efficiency
[ ] And Finally...
[ ] Appendix Using Erlang
[ ] Getting Started with Erlang
[ ] Tools for Erlang
[ ] Where to Learn More
[ ] Colophon
```
